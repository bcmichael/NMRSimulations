import SpecialFunctions: besselj0, besselj1, besselj

"""
    PropagatorCollectionTiming

A 'PropagatorCollectionTiming' contains a cache of propagators that all share
the same RF powers and timing relative to the rotor period. 'phases' stores the
different combinations of RF phases that are used with this timing and set of
powers. 'unphased' holds a propagator with phase of 0 on all channels. 'phased'
holds the set of propagators the phases in 'phases'. These can be generated by
rotating the 0 phase propagator for the full pulse, because these rotations use
the Z operator for each channel which the secular internal spin hamiltonian must
commute with.
"""
struct PropagatorCollectionTiming{T<:AbstractFloat,N,A<:AbstractArray}
    phases::Set{NTuple{N,T}}
    unphased::Vector{Propagator{T,A}}
    phased::Dict{NTuple{N,T}, Propagator{T,A}}

    PropagatorCollectionTiming{T,N,A}() where {T,N,A } = new(Set{NTuple{N,T}}(), Vector{Propagator{T,A}}(),
        Dict{NTuple{N,T}, Propagator{T,A}}())
end

"""
    PropagatorCollectionRF

A 'PropagatorCollectionRF' contains a cache of propagators that all share the
same RF powers. The keys of 'timings' are a starting step within a rotor period
and a number of steps, thus referring to a unique time period for a pulse. The
keys of 'combinations' are similar to the keys of 'timings' but modulo γ_steps.
# The combined propagators for a particular key in 'combinations' are used to
construct the propagators for all time periods which satisfy this
relationship.
"""
struct PropagatorCollectionRF{T<:AbstractFloat,N,A<:AbstractArray}
    combinations::Dict{NTuple{2,Int}, Vector{Propagator{T,A}}}
    timings::Dict{NTuple{2,Int}, PropagatorCollectionTiming{T,N,A}}

    PropagatorCollectionRF{T,N,A}() where {T,N,A } = new(Dict{NTuple{2,Int}, Vector{Propagator{T,A}}}(),
        Dict{NTuple{2,Int}, PropagatorCollectionTiming{T,N,A}}())
end

function add_timing!(collection::PropagatorCollectionRF{T,N,A}, timing::NTuple{2,Int}) where {T,N,A}
    collection.timings[timing] = PropagatorCollectionTiming{T,N,A}()
end

const PulseCache{T,N,A} = Dict{NTuple{N,T}, PropagatorCollectionRF{T,N,A}} where {T,N,A}

function add_rf!(pulse_cache::PulseCache{T,N,A}, rf) where {T,N,A}
    pulse_cache[rf] = PropagatorCollectionRF{T,N,A}()
end

"""
    PropagatorCollectionBlock

A 'PropagatorCollectionBlock' contains a cache of propagators for Blocks that
all share the same rank. 'steps' is a Dict storing the number of steps for each
key, while 'propagators' is a Dict storing the propagator for each key. The keys
are Blocks and the step they start on. This combination fully specifies which
propagator to construct.
"""
struct PropagatorCollectionBlock{T<:AbstractFloat,N,A<:AbstractArray}
    steps::Dict{Tuple{Block{T,N}, Int}, Int}
    propagators::Dict{Tuple{Block{T,N}, Int}, Propagator{T,A}}

    PropagatorCollectionBlock{T,N,A}() where {T,N,A} = new{T,N,A}(Dict{Tuple{Block{T,N}, Int}, Int}(),
                                                                  Dict{Tuple{Block{T,N}, Int}, Propagator{T,A}}())
end

"""
    BlockCache

A BlockCache stores a vector of PropagatorCollectionBlocks each of which caches
the propagators for Blocks of a given rank. Organization by rank allows for
constructing propagators for lower rank Blocks first.
"""
struct BlockCache{T,N,A}
    ranks::Vector{PropagatorCollectionBlock{T,N,A}}

    BlockCache{T,N,A}() where {T,N,A} = new{T,N,A}(Vector{PropagatorCollectionBlock{T,N,A}}())
end

function add_block!(block_cache::BlockCache{T,N,A}, key::Tuple{Block{T,N}, Int}, steps) where {T,N,A}
    rank = key[1].rank
    while rank > length(block_cache.ranks)
        push!(block_cache.ranks, PropagatorCollectionBlock{T,N,A}())
    end
    block_cache.ranks[rank].steps[key] = steps
end

function steps(block_cache::BlockCache{T,N}, key::Tuple{Block{T,N}, Int}) where {T,N}
    rank = key[1].rank
    rank <= length(block_cache.ranks) || throw(KeyError("key $key not found"))
    return block_cache.ranks[rank].steps[key]
end

function haskey(block_cache::BlockCache{T,N}, key::Tuple{Block{T,N}, Int}) where {T,N}
    rank = key[1].rank
    if rank > length(block_cache.ranks)
        return false
    end
    return haskey(block_cache.ranks[rank].steps, key)
end

function getindex(block_cache::BlockCache{T,N}, key::Tuple{Block{T,N}, Int}) where {T,N}
    rank = key[1].rank
    rank <= length(block_cache.ranks) || throw(KeyError("key $key not found"))
    haskey(block_cache.ranks[rank].steps, key) || throw(KeyError("key $key not found"))
    haskey(block_cache.ranks[rank].propagators, key) || throw(KeyError("key $key not initiallized"))
    return block_cache.ranks[rank].propagators[key], block_cache.ranks[rank].steps[key]
end

function setindex!(block_cache::BlockCache{T,N,A}, prop::Propagator{T,A}, key::Tuple{Block{T,N}, Int}, ) where {T,N,A}
    rank = key[1].rank
    rank <= length(block_cache.ranks) || throw(KeyError("key $key not initiallized"))
    haskey(block_cache.ranks[rank].steps, key) || throw(KeyError("key $key not initiallized"))
    block_cache.ranks[rank].propagators[key] = prop
end

struct SimCache{T,N,A}
    step_hamiltonians::Vector{Hamiltonian{T,A}}
    step_propagators::Vector{Propagator{T,A}}
    pulses::PulseCache{T,N,A}
    blocks::BlockCache{T,N,A}

    SimCache{T,N,A}(steps) where {T,N,A} = new{T,N,A}(Vector{Hamiltonian{T,A}}(undef, steps),
        Vector{Propagator{T,A}}(undef,steps), Dict{NTuple{N,T}, PropagatorCollectionRF{T,N,A}}(), BlockCache{T,N,A}())
end

function build_prop_cache(prop_generator::PropagationGenerator{A,T,N}, dims, parameters) where {A,T,N}
    period_steps = parameters.period_steps

    prop_cache = SimCache{T,N,A}(period_steps)
    for n = 1:period_steps
        prop_cache.step_hamiltonians[n] = Hamiltonian(A(undef, dims))
        prop_cache.step_propagators[n] = Propagator(A(undef, dims))
    end
    find_pulses!(prop_cache, prop_generator, parameters)
    allocate_propagators!(prop_cache.pulses, parameters)
    allocate_propagators!(prop_cache.blocks, parameters)
    return prop_cache
end

function find_pulses!(prop_cache, prop_generator::PropagationGenerator, parameters)
    for dim in prop_generator.loops
        for chunk in dim.chunks
            find_pulses!(prop_cache, chunk.initial_elements, parameters)
            find_pulses!(prop_cache, chunk.incrementor_elements, parameters)
        end
    end
    find_pulses!(prop_cache, prop_generator.final.elements, parameters)
    return prop_cache
end

function find_pulses!(prop_cache, elements::Array{SeqElement{T,N}}, parameters) where {T,N}
    for index in eachindex(elements)
        if isassigned(elements, index)
            find_pulses!(prop_cache, elements[index][1], elements[index][2], parameters)
        end
    end
    return prop_cache
end

function find_pulses!(prop_cache, block::Block, start, parameters)
    period_steps = parameters.period_steps
    block_cache = prop_cache.blocks

    start_period = mod1(start, period_steps)
    cache_key = (block, start_period)
    if haskey(block_cache, cache_key)
        return steps(block_cache, cache_key)
    end

    step_total = 0
    if block.repeats == 1
        for element in block.pulses
            step_total += find_pulses!(prop_cache, element, start+step_total, parameters)
        end
    else
        single_repeat = Block(block.pulses, 1)
        for j = 1:block.repeats
            step_total += find_pulses!(prop_cache, single_repeat, start+step_total, parameters)
        end
    end
    add_block!(block_cache, cache_key, step_total)
    return step_total
end

function find_pulses!(prop_cache, pulse::Pulse, start, parameters)
    period_steps = parameters.period_steps
    step_size = parameters.step_size
    pulse_cache = prop_cache.pulses

    steps = Int(pulse.t/step_size)
    rf = pulse.γB1
    if ! haskey(pulse_cache, rf)
        add_rf!(pulse_cache, rf)
    end

    timing = (mod1(start, period_steps), steps)
    if ! haskey(pulse_cache[rf].timings, timing)
        add_timing!(pulse_cache[rf], timing)
    end

    push!(pulse_cache[rf].timings[timing].phases, pulse.phase)
    return steps
end

function allocate_propagators!(block_cache::BlockCache, parameters)
    for collection in block_cache.ranks
        for key in keys(collection.steps)
            collection.propagators[key] = similar(parameters.temps[1])
        end
    end
end

function allocate_propagators!(pulse_cache::PulseCache, parameters)
    for rf_cache in values(pulse_cache)
        allocate_combinations!(rf_cache, parameters)
        for (timing, timing_cache) in rf_cache.timings
            push!(timing_cache.unphased, similar(parameters.temps[1]))
            for phase in timing_cache.phases
                timing_cache.phased[phase] = similar(parameters.temps[1])
            end
        end
    end
end

function allocate_combinations!(rf_cache::PropagatorCollectionRF, parameters)
    nγ = parameters.nγ
    γ_steps = parameters.γ_steps

    unique_timings = Set{Tuple{Int,Int}}()
    for timing in keys(rf_cache.timings)
        push!(unique_timings, (mod1(timing[1], γ_steps), mod(timing[2], γ_steps)))
    end
    for timing in unique_timings
        num_combinations = timing[2] == 0 ? nγ : 2*nγ
        rf_cache.combinations[timing] = [similar(parameters.temps[1]) for n=1:num_combinations]
    end
end

function build_combined_propagators!(prop_cache, Hinternal::SphericalTensor{Hamiltonian{T,A}}, parameters) where {T,A}
    period_steps = parameters.period_steps
    angles = parameters.angles
    step_propagators = prop_cache.step_propagators

    Hrotated = prop_cache.step_hamiltonians
    for n = 1:period_steps
        angles2 = EulerAngles{T}(angles.α+360/period_steps*(n-1), angles.β, angles.γ)
        Hrotated[n].data .= rotate_component2(Hinternal, 0, angles2).data.+Hinternal.s00.data
    end
    temps = [Hamiltonian(similar(Hrotated[1].data, T)) for j = 1:2]
    for (γB1, rf_cache) in prop_cache.pulses
        step_propagators!(step_propagators, γB1, Hrotated, parameters, temps)
        combine_propagators!(rf_cache, step_propagators, parameters)
    end
    return prop_cache
end

function step_propagators!(propagators, rf, Hrotated::Vector{Hamiltonian{T,A}}, parameters, temps) where {T,A}
    period_steps = parameters.period_steps
    step_size = parameters.step_size
    xyz = parameters.xyz

    Hrf = array_wrapper_type(A)(pulse_H(rf,xyz))
    H = similar(temps[1])
    for n = 1:period_steps
        H = real_add!(H, Hrotated[n], Hrf)
        U = expm_cheby!(propagators[n], H, step_size/10^6, temps)
    end
    return propagators
end

"""
    expm_cheby!(U, H, dt, temps)

Modify 'U' to hold a propagator generated from a Hamiltonian ('H') and a time
interval ('dt') using a Chebyshev expansion. Expects 'temps' to be an indexable
collection of two arrays similar to the contents of 'H'.
"""
function expm_cheby!(U, H::Hamiltonian{T,A}, dt, temps) where {T,A}
    nmax = 25
    thresh = T(1E-10)
    bound = eig_max_bound(H.data)
    x = scaledn!(H,bound)
    y = T(-2*dt*pi*bound)
    fill_diag!(U, besselj0(y))
    axpy!(2*im*besselj1(y), x, U)

    t1, t2 = temps
    fill_diag!(t1, 1)
    copyto!(t2, x)

    for n = 3:nmax
        mul!(t1, x, t2, 2, -1)
        j = 2*im^(n-1)*besselj(Cint(n-1), y) # Cast to Cint for type stability when using Float32 as of v1.0.0
        axpy!(j, t1, U)
        if threshold(t1.data, T(thresh/abs(j)))
            break
        end
        t1, t2 = t2, t1
    end
    return U
end

"""
    threshold(A, thresh)

Return true if the absolute value of all elements in A are greater than thresh.
Otherwise return false.
"""
function threshold(A, thresh)
    for n in A
        if abs(n)>thresh
            return false
        end
    end
    return true
end

"""
    eig_max_bound(A)

Calculate an upper bound for the eigenvalues of 'A' based on Gershgorin's
theorem.
"""
function eig_max_bound(A)
    x, y = size(A)
    out = zero(get_precision(A))
    @inbounds for j = 1:y
        current = zero(get_precision(A))
        for k = 1:x
            current += abs(A[k,j])
        end
        out = max(out, current)
    end
    return out
end

function combine_propagators!(rf, step_propagators, parameters)
    γ_steps = parameters.γ_steps

    for (combination, combinations) in rf.combinations
        combine_propagators(combinations, step_propagators, combination, parameters)
    end
    return rf
end

function combine_propagators(combinations, propagators, combination, parameters)
    period_steps = parameters.period_steps
    nγ = parameters.nγ
    γ_steps = parameters.γ_steps
    temp = parameters.temps[1]

    if combination[2] == 0
        for n = 1:nγ
            U = combinations[n]
            position = (n-1)*γ_steps+combination[1]
            copyto!(U, propagators[mod1(position, period_steps)])
            for m = position+1:position+γ_steps-1
                mul!(temp, propagators[mod1(m, period_steps)], U)
                U, temp = temp, U
            end
            combinations[n] = U
        end
    else
        for n = 1:nγ
            U1 = combinations[2*n-1]
            position = (n-1)*γ_steps+combination[1]
            copyto!(U1, propagators[mod1(position, period_steps)])

            for m = position+1:position+combination[2]-1
                mul!(temp,propagators[mod1(m, period_steps)],U1)
                U1, temp = temp, U1
            end
            combinations[2*n-1] = U1

            U2 = combinations[2*n]
            copyto!(U2, propagators[mod1(position+combination[2], period_steps)])
            for m = position+combination[2]+1:position+γ_steps-1
                mul!(temp, propagators[mod1(m, period_steps)], U2)
                U2, temp = temp, U2
            end
            combinations[2*n] = U2
        end
    end
    parameters.temps[1] = temp
    return combinations
end

function build_pulse_props!(pulse_cache, parameters)
    for rf in values(pulse_cache)
        for (timing, timing_cache) in rf.timings
            timing_cache.unphased[1] = build_propagator!(timing_cache.unphased[1], rf, timing, parameters)
        end
    end
    generate_phased_propagators!(pulse_cache, parameters)
    return pulse_cache
end

function build_propagator!(U, rf, timing, parameters)
    nγ = parameters.nγ
    γ_steps = parameters.γ_steps
    temp = parameters.temps[1]

    combinations = rf.combinations[(mod1(timing[1], γ_steps), mod(timing[2], γ_steps))]

    if mod(timing[2], γ_steps) == 0
        start = fld1(timing[1], γ_steps)
        steps = div(timing[2], γ_steps)

        cycles, remain = divrem(steps, nγ)
        cycle_size = nγ
    else
        start = fld1(timing[1], γ_steps)*2-1
        steps = div(timing[2], γ_steps)*2+1

        cycles, remain = divrem(steps, 2*nγ)
        cycle_size = 2*nγ
    end

    if remain != 0
        copyto!(U, combinations[mod1(start, cycle_size)])
        for n = start+1:start+remain-1
            mul!(temp, combinations[mod1(n, cycle_size)], U)
            U, temp = temp, U
        end
    else
        fill_diag!(U,1)
    end

    if cycles>0
        remainder = copy(U)
        for n = start+remain:start+cycle_size-1
            mul!(temp, combinations[mod1(n, cycle_size)], U)
            U,temp = temp, U
        end
        U, temp = pow!(similar(U), U, cycles, temp)
        mul!(temp, remainder, U)
        U, temp = temp, U
    end
    parameters.temps[1] = temp
    return U
end

function generate_phased_propagators!(pulse_cache, parameters)
    for rf in values(pulse_cache)
        for timing in values(rf.timings)
            unphased = timing.unphased[1]
            for phase in timing.phases
                if all(phase .== 0)
                    copyto!(timing.phased[phase], unphased)
                else
                    phase_rotate!(timing.phased[phase], unphased, phase, parameters)
                end
            end
        end
    end
    return pulse_cache
end

function build_block_props!(prop_cache, parameters)
    for collection in prop_cache.blocks.ranks
        for key in keys(collection.steps)
            build_block_prop!(prop_cache, key, parameters)
        end
    end
    return prop_cache
end

function build_block_prop!(prop_cache, key, parameters)
    U, _ = prop_cache.blocks[key]
    block, start = key
    step_total = 0
    if block.repeats == 1
        U = build_nonrepeat_block!(U, block, start, prop_cache, parameters)
    else
        U = build_repeat_block!(U, block, start, prop_cache, parameters)
    end
    prop_cache.blocks[key] = U
    return prop_cache
end

function build_nonrepeat_block!(U, block, start, prop_cache, parameters)
    Uelement, step_total = fetch_propagator(block.pulses[1], start, prop_cache, parameters)
    copyto!(U, Uelement)
    for element in block.pulses[2:end]
        Uelement, steps = fetch_propagator(element, start+step_total, prop_cache, parameters)
        mul!(parameters.temps[1], Uelement,U)
        step_total += steps
        U, parameters.temps[1] = parameters.temps[1], U
    end
    return U
end

function build_repeat_block!(U, block, start, prop_cache, parameters)
    single_repeat = Block(block.pulses, 1)
    Uelement, step_total = fetch_propagator(single_repeat, start, prop_cache, parameters)
    copyto!(U, Uelement)
    for j = 2:block.repeats
        Uelement, steps = fetch_propagator(single_repeat, start+step_total, prop_cache, parameters)
        mul!(parameters.temps[1], Uelement,U)
        step_total += steps
        U, parameters.temps[1] = parameters.temps[1], U
    end
    return U
end

"""
    fetch_propagator(pulse, start, prop_cache, parameters)

Fetch the propagator corresponding to a given 'pulse' and 'start' step from
'prop_cache'. Return the propagator and the number of steps used.
"""
function fetch_propagator(pulse::Pulse, start, prop_cache::SimCache, parameters)
    period_steps = parameters.period_steps
    step_size = parameters.step_size

    steps = Int(pulse.t/step_size)
    timing = (mod1(start, period_steps), steps)
    propagator = prop_cache.pulses[pulse.γB1].timings[timing].phased[pulse.phase]
    return propagator, steps
end

"""
    fetch_propagator(block, start, prop_cache, parameters)

Fetch the propagator corresponding to a given 'block' and 'start' step from
'prop_cache'. Return the propagator and the number of steps used.
"""
function fetch_propagator(block::Block, start, prop_cache::SimCache, parameters)
    period_steps = parameters.period_steps

    start_period = mod1(start, period_steps)
    U, steps = prop_cache.blocks[(block,start_period)]
    return U, steps
end

function γiterate_pulse_propagators!(pulse_cache, parameters, γ_iteration)
    γ_steps = parameters.γ_steps

    for rf in values(pulse_cache)
        for timing_pair in rf.timings
            timing, timing_collection = timing_pair
            if timing[2] <= 2*γ_steps
                iterated_timing = tuple(timing[1]+γ_steps*(γ_iteration-1),timing[2])
                timing_collection.unphased[1] =
                    build_propagator!(timing_collection.unphased[1], rf, iterated_timing, parameters)
            else
                γiterate_propagator!(timing_collection.unphased[1], rf, timing, parameters, γ_iteration)
            end
        end
    end
    generate_phased_propagators!(pulse_cache, parameters)
    return pulse_cache
end

function γiterate_propagator!(U, rf, timing, parameters, γ_iteration)
    γ_steps = parameters.γ_steps
    nγ = parameters.nγ
    temp = parameters.temps[1]

    combinations = rf.combinations[(mod1(timing[1], γ_steps), mod(timing[2], γ_steps))]

    if mod(timing[2], γ_steps) == 0
        start = fld1(timing[1], γ_steps)+γ_iteration-2
        stop = div(timing[2], γ_steps)+start-1

        mul!(temp, U, combinations[mod1(start,nγ)], 'N', 'C')
        mul!(U, combinations[mod1(stop+1, nγ)], temp)
    else
        start = fld1(timing[1], γ_steps)*2-1+2*(γ_iteration-2)
        stop = div(timing[2], γ_steps)*2+start

        mul!(temp, U, combinations[mod1(start, 2*nγ)], 'N', 'C')
        mul!(U, temp, combinations[mod1(start+1, 2*nγ)], 'N', 'C')
        mul!(temp, combinations[mod1(stop+1,2*nγ)], U)
        mul!(U, combinations[mod1(stop+2,2*nγ)], temp)
    end
    return U
end
